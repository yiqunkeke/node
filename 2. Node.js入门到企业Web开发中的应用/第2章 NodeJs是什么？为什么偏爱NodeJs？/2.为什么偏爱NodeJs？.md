---
typora-copy-images-to: ..\file
---

# 为什么偏爱NodeJS

- 前端职责范围变大，**统一开发体验**：

- 随着前端社区的发展，前端的岗位职责也发生了很大的变化，不再是简单的切图，做页面，服务器端的支持工作也是由前端来完成了。

- 对于JavaScript语法的熟悉自然会导致前端对NodeJS有相当大的好感的。

- 因为NodeJS 使用的语言是 JavaScript，前后端开发都使用 JavaScript 同一种语言，中间环节很容易打通

- 但是这并不是NodeJS 在 server端独宠的全部原因。 因为 NodeJS 并不是第一个在 server 端使用 JavaScript 的，更早的有犀牛（JavaScript in Java）

- 让NodeJS 胜出的原因，是官网所提到的事件驱动和异步IO两大特性。这两个特性让 NodeJS在**高并发、IO密集**的场景是有相当明显的优势的。而web开发正是这样的场景。

- 什么叫I/O密集？ I/O密集和 web 有什么关系？NodeJS怎么就擅长web场景了呢？

  

## CPU密集  &  I/O密集

- CPU密集

    - 如果一个程序大部分时间用来做计算、逻辑判断等CPU动作，称之为CPU密集
    - 对应CPU密集的操作主要是压缩，解压，加密，解密，这些纯粹都是CPU运算。
    - 当然图形计算也属于CPU密集，但是很多计算机把它罗列到了GPU。

- I/O密集

    - 如果程序大部分时间用来做存取设备，网络读取操作，称之为IO密集
    - IO密集主要涉及的操作：文件操作、网络操作（相关HTTP）、数据库

- 特点

    - CPU运行指令的速度是非常快的
    - 但是IO相应的提速却没有那么明显

  

## web常见场景

- 静态资源读取
    - 如 静态Html，CSS, JavaScript
    - 除了用CPU来运算路径与文件的对应关系之外，当用户的请求已经到达web server，CPU运算一下 baidu.com 对应的 Html 文件应该在哪，剩下的基本上都是文件的读取操作。
    - 这肯定是IO密集，因为基本上都是IO操作。
- 数据库操作
    - 因为数据库操作本质还是把数据存储在物理磁盘或者内存，总之也是在反复读取这些存储设备，所以最主要的大头还是IO操作，当然也会有少量的CPU运算
- 渲染页面
    - 读取模板文件-----IO操作
    - 根据模板文件生成Html---CPU运算

由此可见，web就是一个典型的IO密集场景。

所以NodeJS对于静态资源读取、数据库操作、渲染页面等web场景，优势明显。也就是说，NodeJS更擅长前面这一层web场景，而不是后端起各种各样服务场景用NodeJS更擅长。

接下来了解下为什么NodeJS擅长高并发？



## 高并发

- 高并发：单位时间内访问量特别大。
- 通用的高并应对之道：
- **增加机器数**（通过负载均衡，处理高并发web请求）
- **增加**每台机器的**CPU数**-----多核

> 类似于饭店由原来的1个大厨增加到3个大厨。通过增加数量来负载均衡，处理高并发请求。当机器数加到一定地步时，我们会发现增加机器数并不是一件很划算的事情，于是就开始使用更好的机器---带有多核（多个CPU）的机器，增加运算能力或者当IO方面是瓶颈时，也可以增加IO方面的能力。
>

- 这种应对高并发的方式，使用NodeJS、Java、Python都没有区别。
- 我们所说的NodeJS性能好，指的是只在单台机器，单个CPU的前提下，在处理Web高并发请求时的能力。



## 进程

- 进程：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
- 比如，用电脑听音乐、上网，对应的音乐播放器和浏览器都分别对应一个程序，当我们双击某个程序将它运行，实际上是将这个程序放到了内存中去执行。这个执行中的程序，就叫做进程。
- 程序运行需要操作系统底层分配给它相应资源才可以运行。都是拿进程作为资源分配和调试的。
- 即正在进行中的程序，我们称之为“进程”。
- 单核的CPU也是可以一边听音乐一边上网的，如何做到的？
- 程序放到内存中，按理说也是调CPU指令一句一句的执行，实际上听音乐和上网并不是同时执行的，而是快速切换不同的进程。
- 多进程：启动多个进程，多个进程可以处理多个任务
- 单核处理多进程：使用调试算法在多个任务（进程）之间快速切换。



## 传统的server如何处理web请求

- 以老李的饭店举例，他给每个厨师分别配了一个服务员，服务员专门负责点菜，厨师负责在后面做菜。厨师做好菜之后就交给服务员，服务员端给客人。然后服务员接着帮队伍中的下一个点菜。
- 由于点菜的动作很快，实际上我们就在类比访问web时，CPU相关的运算
- 而做菜的运作非常慢，就好比CPU运算好之后要进行的IO操作。
- 而单台服务器就面临高并发的问题。web的高并发来 了，老李的做法是：增加厨师和服务员的数量，比如它增加了5个厨师和5个服务员，每个服务员对接一个厨师。
- 对应对web中就是，每来一个请求，服务器就开启一个进程处理用户的请求，CPU就算一下用户想干什么，对于web场景大部分是想操作IO。由于IO是阻塞的，此时这个进程无法关闭，必须等待IO结束，IO结束之后返回。
- 如果多个请求，就开启多个进程。
- 这种通过**开启多个进程**并发处理多个用户请求的方式，起初也能够满足同时处理多个任务的需求。
- 但由于每台机器的能力有限，如果并发请求再增加，只能通过**增加机器数或CPU数**。
- 但是这样存在一个问题：老李发现他雇佣的服务员太悠闲了，有可能是2分钟点菜就结束了而厨师做菜需要10分钟，这样的话，服务员会8分钟没事做，因为大厨没有把菜做好端给人，服务员也不能接待下一个客人。因为他的工作流程就是这样的：服务员接待-----点菜-----菜单交给厨师-----厨师做菜----做好菜给服务员----服务员端给客人-----服务员接待下一位客人。
- 因此不能没完没了的雇佣服务员和厨师，CPU分配的最大进程数是有限的，不能没完没了的分配进程。
- 也就是说，用户并发到一定的数目之后就必须得排队了。比如一台CPU最多能开5000个进程，同时能响应5000个web请求，那么第5001个来了之后只能排队等候。
- 再一个就是，CPU处理的速度是远远快于IO的，在web场景中，CPU运算是相当少的，大头都在IO上。因为在处理IO时，CPU资源处于空转等待IO结果的状态，CPU空转就相当于服务员在玩手机，这样CPU性能降低，对于CPU资源造成非常大的浪费。
- CPU除了响应web，还开了很多需要耗费CPU的东西，如果CPU在空转，就相当于服务员在玩手机，还不做别的事情。对于web来说，浪费CPU等于是一个很大的负担。
- 而NodeJS就很好的解决了这个模型。





## NodeJS工作模型

- 线程：进程内一个相对独立的、可调度的执行单元，与同属一个进程的线程共享进程的资源
- 多线程：启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务

![](https://github.com/yiqunkeke/node/blob/master/2.%20Node.js%E5%85%A5%E9%97%A8%E5%88%B0%E4%BC%81%E4%B8%9AWeb%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/file/nodejs-model.jpg)

> 我们把用在饭店向服务员“点菜”这个动作类比“CPU运算”，这个动作是非常快速的
>
> 把大厨“做饭”类比“IO操作”，IO操作是非常慢的。
>
> 单台机器就面临高并发问题，web的高并发来了，就好比这个饭店，雇佣了5个服务员和5个厨师，每个服务员专门负责“点菜”，就类比每来一个请求（点菜），服务器就开启一个进程（分配一个服务员）专门处理这个请求。CPU就算一下用户想干什么，在web场景中通常是处理IO，在实际中就相当于服务员分析菜单说接下来交给厨师（IO）了。IO通常是阻塞式的，此时这个进程是不能关闭的，需要等待IO结束。如果有多个人“点菜”，就开启多进程，并发处理多个用户的请求。这样一来，一台机器（一个饭店）也能并发处理很多任务（多人点菜）。
>
> 缺陷：一台机器（一个饭店）的能力（饭店太小容不下太多人）是有限的。如果请求再多的话，只能换方法了：比如增加机器台数（开多个饭店分店），增加每台机器的CPU（聘请做饭速度更快的厨师，提高效率）。
>
> 同时，老板（服务器）发现一个大问题：很多服务员由于点菜（CPU运算）过程很快，大部分时间服务员都是空闲的。所以不能没完没了的雇佣服务员（开设进程）和厨师，CPU分配的最大进程数是有限的，就是说用户并发到一定数目之后就必须得排队了。
>
> CPU处理（类似“点菜”）的速度是远远快于IO（类似“做菜”）的。在web场景中, CPU运算是非常少的，大头都在IO上。因为在处理IO的时候，CPU在空转，存在资源非常大的浪费（服务员在空闲时玩手机）。

而NodeJS则很好的解决了上述问题：

> 老赵的饭店（服务器），雇佣了5个厨师（IO），但只雇佣了1个服务员（进程）接待所有客人（请求），客人来了之后点菜并取号后无需排队，直接等候饭菜。服务员将菜单交给厨师后继续接待下一个客人。下一个客人点菜之后，再把菜单放给后厨。等后厨准备好菜之后，就会把菜给相应号码的客人。
>
> 厨师一直在做菜，而服务员也一直在点菜。
















