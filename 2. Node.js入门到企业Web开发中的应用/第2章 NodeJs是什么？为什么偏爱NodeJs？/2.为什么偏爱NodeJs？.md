---
typora-copy-images-to: ..\file
---

# 为什么偏爱NodeJS

- 前端职责范围变大，**统一开发体验**：

- 随着前端社区的发展，前端的岗位职责也发生了很大的变化，不再是简单的切图，做页面，服务器端的支持工作也是由前端来完成了。

- 对于JavaScript语法的熟悉自然会导致前端对NodeJS有相当大的好感的。

- 因为NodeJS 使用的语言是 JavaScript，前后端开发都使用 JavaScript 同一种语言，中间环节很容易打通

- 但是这并不是NodeJS 在 server端独宠的全部原因。 因为 NodeJS 并不是第一个在 server 端使用 JavaScript 的，更早的有犀牛（JavaScript in Java）

- 让NodeJS 胜出的原因，是官网所提到的事件驱动和异步IO两大特性。这两个特性让 NodeJS在**高并发、IO密集**的场景是有相当明显的优势的。而web开发正是这样的场景。

- 什么叫I/O密集？ I/O密集和 web 有什么关系？NodeJS怎么就擅长web场景了呢？

  

## CPU密集  &  I/O密集

- CPU密集

    - 如果一个程序大部分时间用来做计算、逻辑判断等CPU动作，称之为CPU密集
    - 对应CPU密集的操作主要是压缩，解压，加密，解密，这些纯粹都是CPU运算。
    - 当然图形计算也属于CPU密集，但是很多计算机把它罗列到了GPU。

- I/O密集

    - 如果程序大部分时间用来做存取设备，网络读取操作，称之为IO密集
    - IO密集主要涉及的操作：文件操作、网络操作（相关HTTP）、数据库

- 特点

    - CPU运行指令的速度是非常快的
    - 但是IO相应的提速却没有那么明显

  

## web常见场景

- 静态资源读取
    - 如 静态Html，CSS, JavaScript
    - 除了用CPU来运算路径与文件的对应关系之外，当用户的请求已经到达web server，CPU运算一下 baidu.com 对应的 Html 文件应该在哪，剩下的基本上都是文件的读取操作。
    - 这肯定是IO密集，因为基本上都是IO操作。
- 数据库操作
    - 因为数据库操作本质还是把数据存储在物理磁盘或者内存，总之也是在反复读取这些存储设备，所以最主要的大头还是IO操作，当然也会有少量的CPU运算
- 渲染页面
    - 读取模板文件-----IO操作
    - 根据模板文件生成Html---CPU运算

由此可见，web就是一个典型的IO密集场景。

所以NodeJS对于静态资源读取、数据库操作、渲染页面等web场景，优势明显。也就是说，NodeJS更擅长前面这一层web场景，而不是后端起各种各样服务场景用NodeJS更擅长。

接下来了解下为什么NodeJS擅长高并发？



## 高并发

- 高并发：单位时间内访问量特别大。
- 通用的高并应对之道：
- **增加机器数**（通过负载均衡，处理高并发web请求）
- **增加**每台机器的**CPU数**-----多核

> 类似于饭店由原来的1个大厨增加到3个大厨。通过增加数量来负载均衡，处理高并发请求。当机器数加到一定地步时，我们会发现增加机器数并不是一件很划算的事情，于是就开始使用更好的机器---带有多核（多个CPU）的机器，增加运算能力或者当IO方面是瓶颈时，也可以增加IO方面的能力。
>

- 这种应对高并发的方式，使用NodeJS、Java、Python都没有区别。
- 我们所说的NodeJS性能好，指的是只在单台机器，单个CPU的前提下，在处理Web高并发请求时的能力。



## 进程

- 进程：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
- 比如，用电脑听音乐、上网，对应的音乐播放器和浏览器都分别对应一个程序，当我们双击某个程序将它运行，实际上是将这个程序放到了内存中去执行。这个执行中的程序，就叫做进程。
- 程序运行需要操作系统底层分配给它相应资源才可以运行。都是拿进程作为资源分配和调试的。
- 即正在进行中的程序，我们称之为“进程”。
- 单核的CPU也是可以一边听音乐一边上网的，如何做到的？
- 程序放到内存中，按理说也是调CPU指令一句一句的执行，实际上听音乐和上网并不是同时执行的，而是快速切换不同的进程。
- 多进程：启动多个进程，多个进程可以处理多个任务
- 单核处理多进程：使用调试算法在多个任务（进程）之间快速切换。



## 传统的server如何处理web请求

- 以老李的饭店举例，他给每个厨师分别配了一个服务员，服务员专门负责点菜，厨师负责在后面做菜。厨师做好菜之后就交给服务员，服务员端给客人。然后服务员接着帮队伍中的下一个点菜。
- 由于点菜的动作很快，实际上我们就在类比访问web时，CPU相关的运算
- 而做菜的运作非常慢，就好比CPU运算好之后要进行的IO操作。
- 而单台服务器就面临高并发的问题。web的高并发来 了，老李的做法是：增加厨师和服务员的数量，比如它增加了5个厨师和5个服务员，每个服务员对接一个厨师。
- 对应对web中就是，每来一个请求，服务器就开启一个进程处理用户的请求，CPU就算一下用户想干什么，对于web场景大部分是想操作IO。由于IO是阻塞的，此时这个进程无法关闭，必须等待IO结束，IO结束之后返回。
- 如果多个请求，就开启多个进程。
- 这种通过**开启多个进程**并发处理多个用户请求的方式，起初也能够满足同时处理多个任务的需求。
- 但由于每台机器的能力有限，如果并发请求再增加，只能通过**增加机器数或CPU数**。
- 但是这样存在一个问题：老李发现他雇佣的服务员太悠闲了，有可能是2分钟点菜就结束了而厨师做菜需要10分钟，这样的话，服务员会8分钟没事做，因为大厨没有把菜做好端给人，服务员也不能接待下一个客人。因为他的工作流程就是这样的：服务员接待-----点菜-----菜单交给厨师-----厨师做菜----做好菜给服务员----服务员端给客人-----服务员接待下一位客人。
- 因此不能没完没了的雇佣服务员和厨师，CPU分配的最大进程数是有限的，不能没完没了的分配进程。
- 也就是说，用户并发到一定的数目之后就必须得排队了。比如一台CPU最多能开5000个进程，同时能响应5000个web请求，那么第5001个来了之后只能排队等候。
- 再一个就是，CPU处理的速度是远远快于IO的，在web场景中，CPU运算是相当少的，大头都在IO上。因为在处理IO时，CPU资源处于空转等待IO结果的状态，CPU空转就相当于服务员在玩手机，这样CPU性能降低，对于CPU资源造成非常大的浪费。
- CPU除了响应web，还开了很多需要耗费CPU的东西，如果CPU在空转，就相当于服务员在玩手机，还不做别的事情。对于web来说，浪费CPU等于是一个很大的负担。
- 而NodeJS就很好的解决了这个模型。





## NodeJS工作模型

- 线程：进程内一个相对独立的、可调度的执行单元，与同属一个进程的线程共享进程的资源
- 多线程：启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务，是靠调度来做的。
- 如同多进程做多任务一样，多线程也可以做多任务。
- 比如，听音乐这个进程中开启10个线程，这10个线程只能共享音乐播放器这个进程中的内存资源，不能访问其他进程中的资源。
- 如果一个进程只开启一个线程，则这个进程的所有资源都是这个线程的。
- **NodeJS中一个CPU上只开启一个进程，一个进程中只有一个线程**，这是NodeJS的原理。

![](https://github.com/yiqunkeke/node/blob/master/2.%20Node.js%E5%85%A5%E9%97%A8%E5%88%B0%E4%BC%81%E4%B8%9AWeb%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/file/nodejs-model.jpg)

- NodeJS工作模型中，只雇佣一个服务员，这个服务员接待所有客人，客人来了点菜，点菜后不用排队叫个号后直接坐着等了。服务员直接把菜单交给厨师，后面有很多厨师。然后服务员不会等待厨师做菜，而是直接去接待下一个客人，接着点菜，交给厨师。

- 也就是说，在厨师做菜的过程中，服务员不会等待，而是继续做自己的工作（接待---点菜）

- 等厨师做好菜之后，会主动通知服务员，此时服务员会暂停工作，拿到做好的菜根据号码，交给客人。

  

## NodeJS的单线程

- **单线程只是针对主进程，IO操作系统底层多线程调度**。
- NodeJS只负责单进程的监听
- **单线程并不是单进程**。
- 与前面的相悖，前面讲，NodeJS是单进程，单线程。如果我的电脑是8核（8个CPU）,那如果NodeJS是单进程的话，那岂不是剩下的7个CPU不是浪费了吗？
- 了解 NodeJS的都知道，在NodeJS中有一个cluster（集群），专门解决了这个问题。它会根据CPU数量开启有同等数量进程。如果使用cluster模块后，CPU如果有8个，则会开启8个进程，从而不会浪费CPU的能力。



## 常用场景

- NodeJS高性能，只限制在高并发和IO密集的场景下

- web server

- 本地代码构建

- 现在前端直接书写的代码在浏览器上是没法直接工作的，需要本地一些转化工作，我们把这个转化工作叫做构建。如gulp, webpack, babel等相应工具都应运而生。其实**这些东西都是用NodeJS写**的。

- 把ABC编译成DEF，这些编译工作很明显需要通过CPU运算，但是也需要读取文件，也存在IO操作，但是它的CPU的运算量是非常大的，且不是高并发的。我们build代码也就build 2-3次。大头实际上在CPU上。从性能角度考虑，用NodeJS来做并不是很合适，但是为什么这些工具都是用NodeJS来写呢？

- 因为这些都是在处理前端代码，里面有前端特殊的逻辑，前端最了解 ，如果用python，java写的话，出于语法阻碍，写起来束手束脚。而**NodeJS本身具有语法优势**。而且处理文件的这些能力它都有，只不过相对慢了一些。

- 所以了解本地代码构建这方面的知识也是必须的。

- 实用工具开发

  
















