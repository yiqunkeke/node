---
typora-copy-images-to: ..\file
---

# 为什么偏爱NodeJS

- 前端职责范围变大，**统一开发体验**：

- 随着前端社区的发展，前端的岗位职责也发生了很大的变化，不再是简单的切图，做页面，服务器端的支持工作也是由前端来完成了。

- 对于JavaScript语法的熟悉自然会导致前端对NodeJS有相当大的好感的。

- 因为NodeJS 使用的语言是 JavaScript，前后端开发都使用 JavaScript 同一种语言，中间环节很容易打通

- 但是这并不是NodeJS 在 server端独宠的全部原因。 因为 NodeJS 并不是第一个在 server 端使用 JavaScript 的，更早的有犀牛（JavaScript in Java）

- 让NodeJS 胜出的原因，是官网所提到的事件驱动和异步IO两大特性。这两个特性让 NodeJS在**高并发、IO密集**的场景是有相当明显的优势的。而web开发正是这样的场景。

- 什么叫I/O密集？ NodeJS怎么就擅长web场景了呢？I/O密集和 web 有什么关系？

  

## CPU密集  &  I/O密集

- CPU密集

    - 如果一个程序大部分时间用来做计算、逻辑判断等CPU动作，称之为CPU密集
    - 对应CPU密集的操作主要是压缩，解压，加密，解密，这些纯粹都是CPU运算。
    - 当然图形计算也属于CPU密集，但是很多计算机把它罗列到了GPU。

- I/O密集

    - 如果程序大部分时间用来做存取设备，网络读取操作，称之为IO密集
    - IO密集主要涉及的操作：文件操作、网络操作（相关HTTP）、数据库

- 特点

    - CPU运行指令的速度是非常快的
    - 但是IO相应的提速却没有那么明显
  
  

## web常见场景

- 静态资源读取
    - 如 静态Html，CSS, JavaScript
    - 除了用CPU来运算路径与文件的对应关系之外，当用户的请求已经到达web server，CPU运算一下 baidu.com 对应的 Html 文件应该在哪，剩下的基本上都是文件的读取操作。
    - 这肯定是IO密集，因为基本上都是IO操作。
- 数据库操作
    - 因为数据库操作本质还是把数据存储在物理磁盘或者内存，总之也是在反复读取这些存储设备，所以最主要的大头还是IO操作，当然也会有少量的CPU运算
- 渲染页面
    - 读取模板文件-----IO操作
    - 根据模板文件生成Html---CPU运算

由此可见，web就是一个典型的IO密集场景。



## 为什么 NodeJS相对于Java更擅长这种 web 场景？

- 这里所说的 web场景更局限在前面这一层，而不是后端起各种各样的服务用 NodeJS 更擅长。

- 我们是说对于静态资源读取、数据库操作、渲染页面相关前端web场景来说，用NodeJS会优势更明显一些。

- 既然 web 是 IO密集的，那么NodeJS 到底做了什么让它更优势？

  

## 高并发应对之道（传统）

- 高并发：单位时间内访问量特别大。
- 增加机器数（通过负载均衡，处理高并发web请求）
- 增加每台机器的CPU数-----多核

> 增加机器数：
>
> 类似于饭店由原来的1个大厨增加到3个大厨。通过**增加数量**来负载均衡，处理高并发请求。
>
> 增加每台机器的CPU个数：
>
> 类似于饭店将大厨做饭的速度，由1倍提高到4倍。通过**提高效率**来处理高并发请求。



NodeJS性能好，指的是不通过上面两种方式，只在单台机器，单个CPU的前提。



## 进程

- 进程：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
- 即正在进行中的程序，我们称之为“进程”。
- 多进程：启动多个进程，多个进程可以处理多个任务
- 单核处理多进程：是多个任务之间快速切换。

> 比如，用电脑听音乐、上网，对应的音乐播放器和浏览器都分别对应一个程序，当我们双击某个程序将它运行，实际上是将这个程序放到了内存中去执行。这个执行中的程序，就叫做进程。
>
> 程序运行需要操作系统底层分配给它相应资源，它才可以运行。而系统进行资源分配和调试的基本单位就是进程。
>
> 单核的CPU也是可以一边听音乐一边上网的，如何做到的？
>
> 程序放到内存中，按理说也是调CPU指令一句一句的执行，实际上听音乐和上网并不是同时执行的，而是快速切换不同的进程。





## NodeJS工作模型

- 线程：进程内一个相对独立的、可调度的执行单元，与同属一个进程的线程共享进程的资源
- 多线程：启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务

![](https://github.com/yiqunkeke/node/blob/master/2.%20Node.js%E5%85%A5%E9%97%A8%E5%88%B0%E4%BC%81%E4%B8%9AWeb%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/file/nodejs-model.jpg)

> 我们把用在饭店向服务员“点菜”这个动作类比“CPU运算”，这个动作是非常快速的
>
> 把大厨“做饭”类比“IO操作”，IO操作是非常慢的。
>
> 单台机器就面临高并发问题，web的高并发来了，就好比这个饭店，雇佣了5个服务员和5个厨师，每个服务员专门负责“点菜”，就类比每来一个请求（点菜），服务器就开启一个进程（分配一个服务员）专门处理这个请求。CPU就算一下用户想干什么，在web场景中通常是处理IO，在实际中就相当于服务员分析菜单说接下来交给厨师（IO）了。IO通常是阻塞式的，此时这个进程是不能关闭的，需要等待IO结束。如果有多个人“点菜”，就开启多进程，并发处理多个用户的请求。这样一来，一台机器（一个饭店）也能并发处理很多任务（多人点菜）。
>
> 缺陷：一台机器（一个饭店）的能力（饭店太小容不下太多人）是有限的。如果请求再多的话，只能换方法了：比如增加机器台数（开多个饭店分店），增加每台机器的CPU（聘请做饭速度更快的厨师，提高效率）。
>
> 同时，老板（服务器）发现一个大问题：很多服务员由于点菜（CPU运算）过程很快，大部分时间服务员都是空闲的。所以不能没完没了的雇佣服务员（开设进程）和厨师，CPU分配的最大进程数是有限的，就是说用户并发到一定数目之后就必须得排队了。
>
> CPU处理（类似“点菜”）的速度是远远快于IO（类似“做菜”）的。在web场景中, CPU运算是非常少的，大头都在IO上。因为在处理IO的时候，CPU在空转，存在资源非常大的浪费（服务员在空闲时玩手机）。

而NodeJS则很好的解决了上述问题：

> 老赵的饭店（服务器），雇佣了5个厨师（IO），但只雇佣了1个服务员（进程）接待所有客人（请求），客人来了之后点菜并取号后无需排队，直接等候饭菜。服务员将菜单交给厨师后继续接待下一个客人。下一个客人点菜之后，再把菜单放给后厨。等后厨准备好菜之后，就会把菜给相应号码的客人。
>
> 厨师一直在做菜，而服务员也一直在点菜。
















