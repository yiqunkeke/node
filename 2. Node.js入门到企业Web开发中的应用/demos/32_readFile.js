/**  fs(文件系统) == file system
 * 再给大家介绍一个NodeJS中比较核心的模块 fs
 * 处理文件相关的操作要使用这个模块。 
 * 
 * 文件IO是由简单封装的标准POSIX函数提供。
 * 通过 require('fs')使用该模块。
 * 虽然提倡使用异步来操作，但是fs模块中所有的方法都提供了异步和同步两种形式。
 * 推荐大家还是用异步方式
 * 
 * 
 * 在异步方法的最后一个参数都是一个回调函数。
 * 传给回调函数的参数取决于具体方法，跟前面讲events模块事件绑定类似。
 * 
 * 但是所有回调函数的第一个参数都会保留给异常。
 * 这个大家一定要记得，我们以后对外提供一些相关函数的时候，也要按照这个标准来，
 * 因为大家都是这么做的。
 * 
 * 如果操作成功，则第一个参数是 null 或 undefined.
 */

 const fs = require('fs');

//  fs.unlink('/tmp/hello', (err) => {
//      if(err) throw err;
//      console.log('成功删除 /tmp/hello');
//  })


// 第二个参数指定格式为 utf8，默认是 buffer格式。
// 也可以使用 data.toString()将文件转换为字符串格式。
fs.readFile('./32_readFile.js', 'utf8', (err, data) => {
    if(err) throw err;
    console.log(data);
})


// 同步操作---异步名字后面加上Sync，表示同步
const data = fs.readFileSync('./01_run.js', 'utf8');
console.log(data);

/**
 * 虽然同步操作代码写在异步代码下面，但是从执行结果可以看出，
 * 异步读取文件操作交给IO了，等待事件回调会比同步操作慢。
 * 
 * 即使同步代码写在下面，也会比异步的执行早。
 * 同步的执行完之后，异步才有可能被执行到。
 * 
 * 这就意味着一点，在web场景下，用户读一个文件，
 * 难道不是每次等待读到这个文件才返回给用户吗？难道用户读不完就返回给用户吗？
 * 是不是用同步和用异步都一样呢？反正用户总是在等。
 * 
 * 是不一样的。
 * 首先，我们是否得读完一个数据才能返回给用户。这句话是不对的，因为我们可以一部分一部分的
 * 传给用户。
 * 用户确实是需要等待。
 * 我们假设非得等数据读完之后才能返回给用户完成内容。那用同步和用异步有区别吗？
 * 如果只是这一个用户访问这一台机器，实际上是没有区别的。
 * 
 * 但我们在web场景下，我们也提到了一点，高并发，很多用户都在访问，这种时候如果我们写的都是同步的，
 * 就会堵住进程，其他人就读不进来了。
 * 这样就丧失了我们用 nodeJS 最大的优势了：
 * 主进程只是在那处理需求，像个服务员，核心的东西都交给厨师放后面去做了。（异步）
 * 
 * 如果我们直接把服务员给堵住了，则服务员必须等待单个的厨师，其他什么也响应不了了。（同步）
 * 
 * 所以我们在 nodeJS中，尽量用异步操作。
 */
